\subsection{Auto}
\label{auto}

Section \ref{decltype} explained how one could deduce the type of an
expression with \code{decltype} to set the type of a local variable
to match the type of an expression.

Now what about storing a lambda in a local variable, what would be the
type of the variable? As seen in \ref{lambdas-internals}, the type of
the lambda is generated by the compiler, and thus out of reach for the
programmer. The solution is then found in the \code{auto} keyword,
introduced in \cpp11.

\begin{lstlisting}
bool has_string_of_size
(const std::vector<std::string>& strings, std::size_t s)
{
  @\emcode{auto}@ predicate =
     [=](const std::string& string) -> bool
     {
       return string.size() == s;
     };

  return
    std::find_if(strings.begin(), strings.end(), predicate)
    != strings.end();
}
\end{lstlisting}

%-------------------------------------------------------------------------------
\subsubsection{Auto as a Type Placeholder}

The \code{auto} keyword tells the compiler to deduce the actual type
of a variable from whatever is assigned to it. It can be used as long
as there is an expression the compiler can use to find the type. It
can be augmented with \code{const} or \code{\&}.

A typical use is for iterating over an associative container in a for
loop:

\begin{lstlisting}
template<typename F>
void for_each_entry(const std::map<int, int>& m, F& f)
{
  for (const auto& e : m)
    f(e.first, e.second);
}
\end{lstlisting}

In the spirit of \ref{range-based-for-loops}, the type of \code{e} is
deduced to \code{std::map\textless{}int,
  int\textgreater::value\_type}, to which are added the \code{const}
and the \code{\&}.

When used as a return type, the \code{auto} keyword allows to defer
the declaration of the actual return type after the argument list. For
example, if we don't know what is the type but we know it is exactly
the one of a given expression, we can combine this with
\code{decltype}:

\begin{lstlisting}
template<typename F>
auto indirect_call(F&& f) -> decltype(f())
{
  return f();
}
\end{lstlisting}

%-------------------------------------------------------------------------------
\subsubsection{When not to Use \code{auto}}

It is tempting to use the \code{auto} keyword everywhere, especially
for programmers coming from loosely typed languages such as Python or
JavaScript. Moreover, using \code{auto} gives the satisfying feeling
of writing seemingly ``generic'' code that can work with whatever type
is deduced.

In practice, the use of this keyword has lead to very painful to read
code, where nothing can be understood without going through every
expression assigned to an \code{auto} variable, and where entire
functions have to be interpreted to eventually find the returned
type. This is a very high load to pass to the next reader.

\begin{guideline}
Mind the next reader; write what you mean.

Declaring a variable or a function as \code{auto} is like writing an
innuendo, and innuendos make the communication more difficult; if you
see what I mean.

As a rule of thumb, use \code{auto} only if:
\begin{itemize}
\item there is no other way to write the type (e.g. assigning a
  lambda to a variable),
\item \underline{maybe} if the type is a well known idiom (e.g. \code{auto it =
  some\_container.begin()}, or for a loop variable in a range-based for
  loop over an associative container), but I would argue that writing
  the actual type would still be more explanatory for the reader.
\end{itemize}

Absolutely never use \code{auto} in place where you could have used
basic types like \code{int} or \code{bool}, or by laziness. It is not
because it is shorter that it improves the readability. On the
contrary, the readability is improved by being clear about what is
going on.
\end{guideline}
