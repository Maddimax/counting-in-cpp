\section{Auto}

During the pre-\cpp11 every variable, member, argument, etc. has to be
exactly typed. For example, if you were writing a template function
receiving another function as an argument, how could you store the
result of a call of this function in a local variable?

\begin{lstlisting}
template<typename F>
void foo(F& f)
{
  /* some_type */ r = f();
}
\end{lstlisting}

Getting the correct type to put in place of \code{some\_type} was not
obvious, and required a fair share of template metaprogramming. But at
least it was feasible.

Now what about storing a lambda in a local variable, what would be the
type of the variable? As seen in \ref{lambdas-internals}, the type of
the lambda is generated by the compiler, and thus out of reach for the
programmer. The solution is then found in the \code{auto} keyword,
introduced in \cpp11.

\begin{lstlisting}
bool has_string_of_size
(const std::vector<std::string>& strings, std::size_t s)
{
  @\emcode{auto}@ predicate =
     [=](const std::string& string) -> bool
     {
       return string.size() == s;
     };

  return
    std::find_if(strings.begin(), strings.end(), predicate)
    != strings.end();
}
\end{lstlisting}

%-------------------------------------------------------------------------------
\subsection{Auto As A Type Placeholder}

The \code{auto} keyword tells the compiler to deduce the actual type
of a variable from whatever is assigned to it. It can be used every
time a type should be typed, as long as there is an expression the
compiler can use to find the type. It can be augmented with
\code{const} or \code{\&}.

A typical use is for iterating over an associative container in a for
loop:

\begin{lstlisting}
template<typename F>
void for_each_entry(const std::map<int, int>& m, F& f)
{
  for (const auto& e : m)
    f(e.first, e.second);
}
\end{lstlisting}

In the spirit of \ref{range-based-for-loops}, the type of \code{e} is
deduced to \code{std::map\textless{}int,
  int\textgreater::value\_type}, to which are added the \code{const}
and the \code{\&}.

When used as a return type, the \code{auto} keyword allows to defer
the declaration of the actual return type after the argument list. For
example, if you don't know what is the type but you know it is exactly
the one of a given expression, you can combine this with
\code{decltype}:

\begin{lstlisting}
template<typename F>
auto foo(F&& f) -> decltype(f())
{
  return f();
}
\end{lstlisting}

%-------------------------------------------------------------------------------
\subsection{When Not To Use \code{auto}}

It is tempting to use the \code{auto} keyword everywhere, especially
for programmers coming from loosely typed languages such as Python or
JavaScript. Moreover, using \code{auto} gives the satisfying feeling
of writing seemingly ``generic'' code that can work with whatever type
is deduced.

In practice, the use of this keyword has lead to very painful to read
code, where nothing can be understood without going through every
expression assigned to an \code{auto} variable. This is a very high
load to pass to the next reader.

\begin{guideline}
Mind the next reader; write what you mean.
  
Declaring a variable or a function as \code{auto} is like writing an
innuendo, and innuendos make the communication more difficult; if you
see what I mean.

As a rule of thumb, use \code{auto} only if:
\begin{itemize}
\item there is no other way to write the type (e.g. assigning a
  lambda to a variable),
\item \underline{maybe} if the type is a well known idiom (e.g. \code{auto it =
  some\_container.begin()}, or for a loop variable in a range-based for
  loop over an associative container), but I would argue that writing
  the actual type would still be more explanatory for the reader.
\end{itemize}

Absolutely never use \code{auto} in place where you could have used
basic types like \code{int} or \code{bool}, or by laziness. It is not
because it is shorter that it improves the readability. On the
contrary, the readability is improved by being clear about what is
going on.
\end{guideline}
